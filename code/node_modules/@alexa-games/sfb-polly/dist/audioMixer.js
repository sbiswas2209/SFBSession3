"use strict";
/*
 * Copyright 2018 Amazon.com, Inc. and its affiliates. All Rights Reserved.
 *
 * SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0
 *
 * Licensed under the Amazon Software License (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *   http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioMixer = exports.MixMode = exports.TrimOption = exports.SequenceType = void 0;
const sfb_util_1 = require("@alexa-games/sfb-util");
const crypto_1 = require("crypto");
const child_process_1 = require("child_process");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const pollyUtil_1 = require("./pollyUtil");
var SequenceType;
(function (SequenceType) {
    SequenceType["MUSIC"] = "MUSIC";
    SequenceType["SFX"] = "SFX";
})(SequenceType = exports.SequenceType || (exports.SequenceType = {}));
/**
 * Trim option for mixing down the sequence of audio
 */
var TrimOption;
(function (TrimOption) {
    /**
     * mix down the audio to the longest audio in the sequence
     */
    TrimOption["LONGEST"] = "longest";
    /**
     * mix down the audio to the length of the first audio in the sequence
     */
    TrimOption["FIRST"] = "first";
})(TrimOption = exports.TrimOption || (exports.TrimOption = {}));
var MixMode;
(function (MixMode) {
    MixMode["CONCATENATE"] = "concat";
    MixMode["LAYER"] = "layer";
})(MixMode = exports.MixMode || (exports.MixMode = {}));
/**
 * Builder for mixing multiple audio files using the FFMPEG binary
 */
class AudioMixer {
    constructor(ffmpegPath, audioWorkingDir, audioAccessor) {
        this.ffmpegPath = ffmpegPath;
        this.audioWorkingDir = audioWorkingDir;
        this.audioAccessor = audioAccessor;
        this.audioSequence = [];
    }
    /**
     * add audio item to the sequence to mix
     * @param audio
     */
    addAudio(audio) {
        this.audioSequence.push(audio);
    }
    /**
     * add polly item in the audio sequence
     * @param polly
     * @returns resulting audio file path in disc.
     */
    async addPollyItem(request) {
        const pollyKeyString = JSON.stringify(request);
        const pollyFileName = `polly${crypto_1.createHash('md5').update(pollyKeyString).digest('hex')}.mp3`;
        try {
            const exists = !pollyUtil_1.PollyUtil.pollyConfig.dontUseCache && await this.audioAccessor.exists(pollyFileName);
            if (!exists && !fs.existsSync(path.resolve(this.audioWorkingDir, pollyFileName))) {
                console.info(`[INFO] Calling AWS Polly with request=${JSON.stringify(request, null, 4)}`);
                const pollyUtil = new pollyUtil_1.PollyUtil(this.audioAccessor);
                await pollyUtil.synthesize(request, this.audioWorkingDir, pollyFileName);
            }
            const pollyUrl = await this.audioAccessor.getAudioURL(pollyFileName);
            this.audioSequence.push({
                sequenceType: SequenceType.SFX,
                filename: pollyFileName,
                url: pollyUrl,
                delayMs: request.delayMs,
                fadeInDuration: 0,
                fadeOutDuration: 0,
                fadeOutTime: 0,
                volume: 1.0 // Use Polly Volume to adjust your voice volume before mixing, will be better this way
            });
            return path.resolve(this.audioWorkingDir, pollyFileName);
        }
        catch (err) {
            throw err;
        }
    }
    /**
     * Mix down the audio using FFMPEG binary with the generated file name, and return the URL of the resulting audio.
     * @param setting audio mix setting
     * @returns resulting audio file path in disc
     */
    async mix(setting) {
        if (this.audioSequence.length === 0) {
            return "";
        }
        if (this.audioSequence.length === 1) {
            const item = this.audioSequence[0];
            if (!this.isAudioModified(item)) {
                return path.resolve(this.audioWorkingDir, item.filename);
            }
        }
        const sequenceString = this.audioSequence
            .map((audio) => JSON.stringify(audio))
            .reduce((prev, curr, i, arr) => {
            if (prev) {
                return `${prev} ${curr}`;
            }
            else {
                return curr;
            }
        });
        const checksum = crypto_1.createHash('md5').update(sequenceString + JSON.stringify(setting)).digest('hex');
        const generatedFilename = `${checksum}.mp3`;
        const mixedAudioPath = path.resolve(this.audioWorkingDir, generatedFilename);
        const audioExistsInCache = !pollyUtil_1.PollyUtil.pollyConfig.dontUseCache && await this.audioAccessor.exists(generatedFilename);
        const audioExistsInDisc = fs.existsSync(mixedAudioPath);
        if (!audioExistsInCache) {
            await this.downloadSequenceItems(this.audioSequence);
            const command = this.getFFMPEGCommand(this.audioSequence, generatedFilename, setting);
            try {
                if (!audioExistsInDisc) {
                    console.info(`Processing audio with FFMPEG: ${command}`);
                    const execStart = new Date().getTime();
                    child_process_1.execSync(command);
                    const execDuration = new Date().getTime() - execStart;
                    console.debug(`ffmpeg process finished in ${execDuration} ms.`);
                }
                else {
                    console.info(`Skipping ffmpeg to generate '${generatedFilename}' since it exists in disc already. `);
                }
            }
            catch (err) {
                throw err;
            }
        }
        return mixedAudioPath;
    }
    isAudioModified(item) {
        return !((!item.delayMs || item.delayMs === 0) && (!item.fadeInDuration || item.fadeInDuration === 0)
            && (!item.fadeOutDuration || item.fadeOutDuration === 0) && (!item.fadeOutTime || item.fadeOutTime === 0) && (!item.volume || item.volume === 1.0));
    }
    /**
     * Check if the audio files in the sequence are available locally, then download the ones that are not available.
     */
    async downloadSequenceItems(sequence) {
        const downloadTasks = [];
        for (let audio of sequence) {
            downloadTasks.push(this.checkAndDownloadAudio(audio));
        }
        await Promise.all(downloadTasks);
    }
    /**
     * Check if the given audio file exists locally, if not download that file.
     */
    async checkAndDownloadAudio(audio) {
        const filePath = path.resolve(this.audioWorkingDir, audio.filename);
        const existsLocally = fs.existsSync(filePath);
        if (!existsLocally) {
            console.info(`[INFO] Downloading '${audio.url}' for mixing.`);
            await this.audioAccessor.downloadAudio(audio.url, this.audioWorkingDir);
        }
        else {
            console.info(`[INFO] Skip downloading ${audio.url}. Available locally already.`);
        }
    }
    /**
     * Generate a FFMPEG command string with option flags and values given the audio sequence and setting
     */
    getFFMPEGCommand(audioSequence, outputName, setting) {
        const postMixFilepath = path.join(this.audioWorkingDir, outputName);
        if (setting.mode === MixMode.LAYER) {
            let inputFiles = "";
            let streamProcessingList = "";
            let streamList = "";
            for (let i = 0; i < audioSequence.length; i++) {
                const sequence = audioSequence[i];
                inputFiles += ` -i "${sfb_util_1.sanitizeCommandLineParameter(path.join(this.audioWorkingDir, sequence.filename))}" `;
                // Use adelay filter to add a delay to the start of various sounds
                // List this  [1:a] adelay=2500|2500 [delayed];  // 2500 listed for each audio channel
                const volumeFilter = (sequence.volume != 1.0) ? `volume=volume=${sfb_util_1.sanitizeCommandLineParameter(sequence.volume)}` : "";
                const fadeInFilter = (sequence.fadeInDuration) ? `afade=t=in:start_time=0:d=${sfb_util_1.sanitizeCommandLineParameter(sequence.fadeInDuration)}` : "";
                const fadeOutFilter = (sequence.fadeOutTime && sequence.fadeOutDuration) ? `afade=t=out:start_time=${sfb_util_1.sanitizeCommandLineParameter(sequence.fadeOutTime)}:d=${sfb_util_1.sanitizeCommandLineParameter(sequence.fadeOutDuration)},atrim=duration=${sfb_util_1.sanitizeCommandLineParameter(sequence.fadeOutTime + sequence.fadeOutDuration)}` : "";
                const adelayFilter = (sequence.delayMs) ? `adelay=${sfb_util_1.sanitizeCommandLineParameter(sequence.delayMs)}|${sfb_util_1.sanitizeCommandLineParameter(sequence.delayMs)}` : "";
                let filtersString = "";
                if (fadeInFilter) {
                    filtersString += fadeInFilter;
                }
                if (fadeOutFilter) {
                    if (filtersString) {
                        filtersString += ",";
                    }
                    filtersString += fadeOutFilter;
                }
                if (adelayFilter) {
                    if (filtersString) {
                        filtersString += ",";
                    }
                    filtersString += adelayFilter;
                }
                if (volumeFilter) {
                    if (filtersString) {
                        filtersString += ",";
                    }
                    filtersString += volumeFilter;
                }
                if (filtersString.trim().length > 0) {
                    streamProcessingList += `[${i}:0] ${filtersString}[in${i}]; `;
                    streamList += `[in${i}]`;
                }
                else {
                    streamList += `[${i}:0]`;
                }
            }
            ;
            const trimCommand = setting.trim ? sfb_util_1.sanitizeCommandLineParameter(setting.trim) : TrimOption.LONGEST;
            const ffmpegOptions = ` -filter_complex "${streamProcessingList} ${streamList} amix=inputs=${this.audioSequence.length}:duration=${trimCommand}:dropout_transition=0[out];[out]volume=${this.audioSequence.length}" -t 240 -ac 1 -c:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 "${sfb_util_1.sanitizeCommandLineParameter(postMixFilepath)}" -loglevel fatal`;
            const ffmpegCommand = `"${sfb_util_1.sanitizeCommandLineParameter(this.ffmpegPath)}" -y ${inputFiles} ${ffmpegOptions}`;
            return ffmpegCommand;
        }
        else {
            let inputFiles = "";
            let concatenatingStreams = "";
            for (let i = 0; i < audioSequence.length; i++) {
                const sequence = audioSequence[i];
                const inputStream = `[${i}:0]`;
                inputFiles += ` -i "${sfb_util_1.sanitizeCommandLineParameter(path.join(this.audioWorkingDir, sequence.filename))}" `;
                concatenatingStreams += inputStream;
            }
            ;
            const concatCommand = `"${sfb_util_1.sanitizeCommandLineParameter(this.ffmpegPath)}" -y ${inputFiles} -filter_complex "${concatenatingStreams} concat=n=${audioSequence.length}:v=0:a=1" -t 240 -ac 1 -c:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 "${sfb_util_1.sanitizeCommandLineParameter(postMixFilepath)}" -loglevel fatal`;
            return concatCommand;
        }
    }
}
exports.AudioMixer = AudioMixer;
//# sourceMappingURL=audioMixer.js.map