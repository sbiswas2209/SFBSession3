"use strict";
/*
 * Copyright 2018 Amazon.com, Inc. and its affiliates. All Rights Reserved.
 *
 * SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0
 *
 * Licensed under the Amazon Software License (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *   http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryBlockRange = void 0;
class StoryBlockRange {
    constructor(startRow, startColumn, endRow, endColumn) {
        if (startRow !== 0 && endRow < startRow) {
            throw new Error(`endRow(${endRow}) less than startRow(${startRow})`);
        }
        if (startColumn < 0) {
            throw new Error(`startColumn cannot be less than 0.`);
        }
        if (endColumn < 0) {
            throw new Error(`endColumn cannot be less than 0.`);
        }
        if (startRow === endRow && endColumn < startColumn) {
            throw new Error('endColumn less than startColumn on a single row.');
        }
        this.start = {
            row: startRow,
            column: startColumn
        };
        this.end = {
            row: endRow,
            column: endColumn
        };
    }
    cropToRange(line, row) {
        if (row < this.start.row || row > this.end.row) {
            return '';
        }
        if (row === this.start.row && row === this.end.row) {
            return line.substring(this.start.column, this.end.column);
        }
        else if (row === this.start.row) {
            return line.substring(this.start.column);
        }
        else if (row === this.end.row) {
            return line.substring(0, this.end.column);
        }
        return line;
    }
    intersectsWith(b) {
        return StoryBlockRange.rangesIntersect(this, b);
    }
    static rangesIntersect(a, b) {
        if (a.end.row < b.start.row || a.start.row > b.end.row) {
            return false;
        }
        if (a.end.row === b.start.row &&
            a.end.column <= b.start.column) {
            return false;
        }
        if (b.end.row === a.start.row &&
            b.end.column <= a.start.column) {
            return false;
        }
        return true;
    }
}
exports.StoryBlockRange = StoryBlockRange;
//# sourceMappingURL=storyBlockRange.js.map